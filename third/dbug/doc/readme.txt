
	dbug库的作用是在单元测试的时候可以像使用gdb调试程序一样直观地查看函数的调用。

	dbug最初是由Fred Fish(November 4, 1952 - April 20, 2007)编写的，AFC项目中使
用的版本是经Binayak Banerjee和Michael Widenius修改过的版本，他们所修改的内容可
以在源码中查看。Sergei Golubchik在上述版本基础上再为MySQL项目订制了一个版本，对
MySQL其它模块有所依赖，因此AFC不使用该版本。

	dbug的源码很简单:1个C文件(原始文件名为dbug.c，在公司项目中修改为PbDebug.c)，
1个H文件(原始文件名为dbug.h，在公司项目中修改为PbDebug.h)，提供了11个需要使用者
关心的接口(事实上是11个宏)，下列接口中01-06为常用接口。

dbug库接口列表：
	01. DBUG_ENTER(a1)
	02. DBUG_RETURN(a1)
	03. DBUG_VOID_RETURN
	04. DBUG_PRINT(keyword,arglist)
	05. DBUG_PUSH(a1)
	06. DBUG_PROCESS(a1)
	07. DBUG_EXECUTE(keyword,a1)
	08. DBUG_POP()
	09. DBUG_SETJMP
	10. DBUG_LONGJMP
	11. DBUG_DUMP(keyword,a1,a2)

	下面以郑州项目的消息0400520D的处理来讲述一下如何使用dbug，代码在convert_zz/
msg0400502D.c中msgin0400520D函数中，在该函数中开启了调试选项："d:t:O"(每个选项
的函数见后文)。
	当进入函数msgin0400520D()之后，会在终端打印如下信息：
	>msgin0400520D
	| INFO: ParaType [1002] ParaVersion[1000]
	| >SendParaDownReq04005107
	| <SendParaDownReq04005107
	| >ParaUpdateParaInfo
	| | INFO: PARA_TYPE [1002] PARA_VERSION_INFO [1000] ACTIVE_DATE [20160708]
	| | DEBUG: PARA_EXTRA_INFO Insert error
	| <ParaUpdateParaInfo
	| INFO: ParaType [1005] ParaVersion[1]
	| >DownloadParaFileByFtp
	| <DownloadParaFileByFtp
	| >ParaUpdateParaInfo
	| | INFO: PARA_TYPE [1005] PARA_VERSION_INFO [1] ACTIVE_DATE [20160708]
	| | DEBUG: PARA_EXTRA_INFO Insert error
	| <ParaUpdateParaInfo
	...........................
	.......此处省略200行.......
	...........................
	| >ReportParaVersionAgain
	| <ReportParaVersionAgain
	<msgin0400520D

	注：
		">func"：表示进入函数func
		"<func"：表示离开函数func
		"|	  "：同一层次的函数中打印的信息的第一个"|"在同一列上，比如下面伪函数：
		func()
		{
			funcA();
			funcB();
		}
		输出：
		>func
		|  >funcA
		|  <funcA
		|  >funcB
		|  <funcB
		<func
	也可以参照example.c(汉诺塔的例子)程序来理解。
	
	因此，msgin0400520D函数中输出的信息可以如下理解：
	0400520D报文进入msgin0400520D函数处理时，检查到第一个参数类型是1002（在郑州
中参数ID为1002的参数是即时生效参数，不需要下载文件，只需要发送04005107请求报文）
，调用函数SendParaDownReq04005107发送请求消息，接着调用函数ParaUpdateParaInfo把
参数信息更新入数据库，在更新数据库的函数处理中打印了两条信息INFO/DEBUG；处理完
参数1002之后，检查到下一条参数信息是1005,是非即时生效参数，需要下载文件，因此调
用函数DownloadParaFileByFtp，下载成功后需要像和1002那样把参数信息更新到数据库中
去；当所有参数都下载完成之后调用函数ReportParaVersionAgain上报一次参数的版本信
息。最后退出msgin0400520D的处理流程。

	通过以上的输出，我们可以很直观地了解程序运行到哪一步。在测试程序的时候我们
也可以通过日志函数多输出些信息来实现这一点需求，但是如果在修正问题之后不删除这
些日志信息就会在日志文件中增加了许些不必要的日志信息，删除之后又不方便下一次的
调试，因为谁也不能保证一次测试成功之后就再也不会出现问题。而dbug则是通过调试选
项来决定调试信息的输出与否，不必须将调试信息部分的代码删除。
	上面提到msgin0400520D函数中开启的调试选项是"d:t:O"，代码为：
	DBUG_PUSH("d:t:O");
	当不需要输出调试信息的时候，只需要把"d:t:O"改写成""即可，或者把上述代码删
除即可，如果msgin0400520D函数是由个人编写的调试程序调起的，把DBUG_PUSH("d:t:O");
写在个人的TestCase中即可。

	dbug的使用
	从example.c中可以看出，使用dbug的主要内容是：
	1、使用DBUG_PUSH设置调试选项;
	2、通过DBUG_PROCESS设置程序名（不是必须的，若不设置，就会使用默认的"dubg"）;
	3、要想在函数中使用dbug就需要调用DBUG_ENTER才行;
	4、在函数中调用DBUG_PRINT/DBUG_DUMP等功能;
	5、函数结束时需要调用DBUG_RETURN/DBUG_VOID_RETURN，前者有返回真，后者无。

	通常情况下工程项目编译出来的程序分为Debug版和Release版，在Debug版中启用调试
选项，在Release版中关闭调试选项。在dbug中默认是启用Debug开关的，毕竟它本身就是
用来debug的。从头文件可以看得出来：如果未定义DBUG_ON和_lint则表示启动Debug。
	AFC项目原本调试程序的方法有：打印日志、gdb两种，基本上都能够解决掉问题，因此
AFC项目中默认是不开启Debug选项。若想使用dbug时，需要在编译的时候加上宏DBUG_ON。

	当不想使用dbug的时候，可以有两种方法不启用dbug：
	1、在调用dbug的接口前定义宏"DBUG_OFF"，这点可以从PbDebug.h中可以看出。
	2、不使用DBUG_PUSH来设置调试选项，或者选项中空字符串，即可以不使用dbug。
	建议使用第一种方法.

	DBUG_PUSH接口用来调试调试选项，它的参数是一个字符串，格式如下：
	<field_1>:<field_2>:...:<field_N>
	每个filed又可以如下表示：
	flag[,modifier,modifier,...,modifier]
	举个例子，上面提到的msgin0400520D的调试选项是："d:t:O"，事实上默认情况下调
试选项是："d:t"，它们的意思可以查看下表，也可以直接查看源码中的英文注释。这个选
项是最常用的。它的信息都打印在屏幕上，如果想让它把信息都输出到文件中，则可以使
用o选项，即"d:t:O:o,dbug.out"，执行程序过后，dbug的相关输出信息都被写入dbug.out
文件中了。

┏━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃  标记  ┃                               描述                                 ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   N    ┃ 给调试输出的每一行编号                                             ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   F    ┃ 对调试或跟踪输出的每一行识别源文件名                               ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   L    ┃ 为调试或跟踪输出的每一行识别源文件行号                             ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   P    ┃ 为调试或跟踪输出的每一行打印当前进程名字                           ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   n    ┃ 为调试或跟踪输出的每一行打印当前函数嵌套深度                       ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   i    ┃ 对调试或跟踪输出的每一行用PID或线程ID识别进程                      ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   o    ┃ 重定向调试器输出流到指定文件.默认输出是stderr 文件                 ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   r    ┃ 当推出一个新状态时,不继承前状态的操作嵌套深度级别.当输出在左边空白 ┃
┃        ┃ 开始时有用                                                         ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   O    ┃ 类似于o, 但是文件在每次写操作之间被冲刷.当需要之时,文件在每次写操作┃
┃        ┃ 之间被关闭之后重新打开                                             ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   p    ┃ 限制调试器作用于指定进程.为使调试器动作,一个进程必须用DBUG_PROCESS ┃
┃        ┃ 宏来识别,且匹配列表中的一个                                        ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   D    ┃ 在每个调试起输出行后延迟.参量一个十分之一秒为单位来延迟的数,它受限 ┃
┃        ┃ 于机器的能力.比如 -#D,20 指定一个2秒的延迟                         ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   S    ┃ 在每个调试过的函数做_sanity(_file_,_line_)函数直到 _sanity()返回不 ┃
┃        ┃ 同于0的结果.多数时候与safemalloc 一起用来找出内存漏洞              ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃   d    ┃ 允许对当前状态从DBUG_<N>宏输出.可能跟着一列关键词,这些关键词仅对那 ┃
┃        ┃ 些带有关键词的DBUG宏选择输出.一个空的关键词列意味着对所有宏输出    ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃        ┃ 限制调试和/或跟踪,以及简单设定于列出名字的函数.注意,空列将禁止所用 ┃
┃   f    ┃ 函数.应该给出适当的d 或 t 标记,如果它们被允许了,这个标记仅限制它们 ┃
┃        ┃ 的动作                                                             ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃        ┃ 允许函数调用/退出跟踪行.可能跟着一个给出最大跟踪级别的数字列(只含一┃
┃   t    ┃ 个修改量),超过这个数字,调试中或跟踪中的宏不能产生任何输出. 默认为一┃  
┃        ┃ 个编译时间选项                                                     ┃
┣━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃        ┃ 允许解析,创建名为的dbugmon.out文件,它包含可用来简单设定程序的信息. ┃
┃   g    ┃ 可能跟着一列关键词,它们是选择只对列中的函数做简单设定.一个空列意味 ┃
┃        ┃ 着所有函数都要考虑到                                               ┃
┗━━━━┻━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
