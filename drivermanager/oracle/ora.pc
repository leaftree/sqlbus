
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <unistd.h>
#include <sys/errno.h>

#include "util.h"
#include "dbug.h"
#include "dbdriver.h"

EXEC SQL INCLUDE sqlda;
EXEC SQL INCLUDE sqlca;
EXEC SQL INCLUDE sqlcpr;
EXEC SQL INCLUDE sqlapr;

static SQLDA *bind_dp;
static SQLDA *select_dp;

/**
 * dbSetErrorWithErrno - 使用GLibc全局变量errno设置错误信息
 *
 * @error: 错误信息结构
 * @errorno: 错误编号
 *
 * return value:
 *  No return value
 */
static void dbSetErrorWithErrno(error_info *error, int errorno)
{
	if(!error) return;

	error->ecode = errorno;
	snprintf(error->errstr, sizeof(error->errstr), "%s", strerror(error->ecode));
}

/**
 * dbSetError - 设置错误信息，格式类似sprintf
 *
 * @fmt: 信息格式
 * @...: 可变参数项
 *
 * return value:
 *  No return value
 */
static void dbSetError(error_info *error, const char *fmt, ...)
{
	if(!error) return;

	error->ecode = errno;
	va_list vp;
	va_start(vp, fmt);
	vsnprintf(error->errstr, sizeof(error->errstr), fmt, vp);
	va_end(vp);
}

/**
 * dbSetORAError - 获取Oracle错误信息
 *
 * @error: 错误信息结构
 *
 * return value:
 *  No return value
 */
static void dbSetORAError(error_info *error)
{
	char stm[512] = "";
	char message[512] = "";
	size_t sqlfc = 0, stmlen = 512, message_length = 0, buffer_size = 512;

	if(!error) return;

	sqlgls(stm, &stmlen, &sqlfc);
	sqlglm((unsigned char *)message, &buffer_size, &message_length);

	rtrim(message, message_length);
	if(message[strlen((char*)message)-1] == 0x0a)
		message[strlen((char*)message)-1] = 0x0;

	error->ecode = SQLCODE;
	snprintf(error->errstr, sizeof(error->errstr), "%s", message);
}

/**
 * isSelectStatment - 判断一个字符串是否为Query类型SQL
 *
 * @stmt: 待检查的字符串
 *
 * @isSelectStatment不进行严格检查，即不检查SQL语法，只判断前1个Token
 *
 * return value:
 *  0: 不是QUERY类型SQL
 *  1: 是QUERY类型SQL
 */
static int isSelectStatment(char *stmt)
{
	static char select[] = "SELECT";

	if(strncasecmp(select, stmt, strlen(select)))
		return 0;
	return 1;
}

/**
 * allocDescriptors - 为指示变量和存储数据的变量申请空间
 *
 * @hstmt: SQL语句执行的句柄
 * @max_col_cnt: 最大列数或者是最大的宿主变量数
 * @max_vname_len: 列名的最大长度
 * @max_iname_len: 指示变量名的最大长度
 *
 * return value:
 *  RETURN_FAILURE: 分配空间失败
 *  RETURN_SUCCESS: 分配空间成功
 */
static int allocDescriptors(HSTMT hstmt, int max_col_cnt, int max_vname_len, int max_iname_len)
{
	DBUG_ENTER(__func__);

	if ((bind_dp = SQLSQLDAAlloc(SQL_SINGLE_RCTX, max_col_cnt,
					max_vname_len, max_iname_len)) == (SQLDA *) 0)
	{
		dbSetError(hstmt->error, "Cannot allocate memory for bind descriptor.");
		DBUG_RETURN(RETURN_FAILURE); 
	}

	if ((select_dp = SQLSQLDAAlloc (SQL_SINGLE_RCTX, max_col_cnt,
					max_vname_len, max_iname_len)) == (SQLDA *) 0)
	{
		dbSetError(hstmt->error, "Cannot allocate memory for select descriptor.");
		DBUG_RETURN(RETURN_FAILURE); 
	}

	int i;
	select_dp->N = max_col_cnt;
	for(i = 0; i < max_col_cnt; i++)
	{
		bind_dp->I[i]   = (short*) malloc(sizeof(short));
		select_dp->I[i] = (short*) malloc(sizeof(short));
		bind_dp->V[i]   = (char *) malloc(sizeof(char));
		select_dp->V[i] = (char *) malloc(sizeof(char));
	}

	DBUG_RETURN(RETURN_SUCCESS); 
}

/**
 * runNonQueryStatment - 执行一个非QUERY类型语句
 *
 * @hstmt: SQL语句执行的句柄
 * @statement: 待执行的SQL语句
 *
 * return value:
 *  IAPFAIL: 执行失败，或者执行成功但提交失败
 *  IAPSUCC: 执行成功
 */
static int runNonQueryStatment(HSTMT hstmt, char *statement)
{
	EXEC SQL BEGIN DECLARE SECTION;
	varchar caSqlStmt[ORA_MAX_SQL_LEN];
	EXEC SQL END DECLARE SECTION;

	hstmt->result_code = ORA_SQL_EXEC_RESULT_CODE_SUCCESS;

	caSqlStmt.len = sprintf((char*)caSqlStmt.arr, "%s", statement);
	EXEC SQL EXECUTE IMMEDIATE :caSqlStmt;
	if(SQLCODE != IAPSUCC)
	{
		if(SQLCODE == 1403)
			hstmt->result_code = ORA_SQL_EXEC_RESULT_CODE_NOT_FOUND;
		else
			hstmt->result_code = ORA_SQL_EXEC_RESULT_CODE_FAILURE;

		dbSetORAError(hstmt->error);
		EXEC SQL ROLLBACK WORK;
		return(IAPFAIL);
	}
	else
	{
		EXEC SQL COMMIT WORK;
		if(SQLCODE != IAPSUCC)
		{
			dbSetORAError(hstmt->error);
			return(IAPFAIL);
		}
	}

	dbSetErrorWithErrno(hstmt->error, 0);
	return(IAPSUCC);
}

/**
 * Proc_db_connect - 连接登录数据库
 *
 * @hdbc: 连接句柄
 *
 * return value
 *  RETURN_INVALID: 参数无效
 *  RETURN_FAILURE: 登录失败
 *  RETURN_SUCCESS: 登录成功
 */
static int Proc_db_connect(HDBC hdbc)
{
	DBUG_ENTER(__func__);

	EXEC SQL BEGIN DECLARE SECTION;
	varchar     dbpwd[21];
	varchar     dbuserid[21];
	EXEC SQL END DECLARE SECTION;

	if(hdbc == NULL)
		DBUG_RETURN(RETURN_INVALID);

	DBUG_PRINT(__func__, ("LINE:%d DBOPENDATABASE BEGIN!!!",__LINE__));

	strcpy((char*)dbuserid.arr, hdbc->username);
	dbuserid.len = strlen(hdbc->username);
	strcpy((char*)dbpwd.arr, hdbc->password);
	dbpwd.len = strlen(hdbc->password);

	EXEC SQL CONNECT :dbuserid IDENTIFIED BY :dbpwd;
	if( SQLCODE != IAPSUCC )
	{
		dbSetORAError(hdbc->error);
		DBUG_PRINT(__func__, ("LINE:%d CONNECT TO DB ERROR & DBOPENDATABASE END!!!",__LINE__));
		DBUG_RETURN(RETURN_FAILURE);
	}

	DBUG_PRINT(__func__, ("LINE:%d DB_LOGIN SUCCESSFULLY END!!!",__LINE__));

	DBUG_RETURN(RETURN_SUCCESS);
}

/**
 * DBConnectInitialize - 连接数据库句柄初始化
 *
 * @hdbc: 句柄
 *
 * return value:
 *  RETURN_INVALID: 参数无效
 *  RETURN_FAILURE: 分配内存空间失败
 *  RETURN_SUCCESS: 初始化成功
 */
int DBConnectInitialize(HDBC *hdbc)
{
	DBUG_ENTER(__func__);

	if(hdbc == NULL)
		DBUG_RETURN(RETURN_INVALID);

	*hdbc = malloc(sizeof(connection));
	if(*hdbc == NULL) {
		DBUG_RETURN(RETURN_FAILURE);
	}

	(*hdbc)->error = malloc(sizeof(error_info));
	if((*hdbc)->error == NULL) {
		mFree(hdbc);
		DBUG_RETURN(RETURN_FAILURE);
	}

	DBUG_RETURN(RETURN_SUCCESS);
}

/**
 * DBConnectFinished - 数据库连接句柄使用结束，翻译资源
 *
 * @hdbc: 句柄
 *
 * return value:
 *  RETURN_INVALID: 参数无效
 *  RETURN_SUCCESS: 释放资源成功
 */
int DBConnectFinished(HDBC hdbc)
{
	DBUG_ENTER(__func__);

	if(hdbc == NULL)
		DBUG_RETURN(RETURN_INVALID);

	mFree(hdbc->error);
	mFree(hdbc);

	DBUG_RETURN(RETURN_SUCCESS);
}

/**
 * DBConnect - 数据库连接
 *
 * @hdbc: 连接句柄
 * @username: 数据库用户
 * @password: 数据库用户密码
 * @database: 数据库实例
 *
 * return value:
 *  RETURN_INVALID: 参数无效
 *  RETURN_FAILURE: 连接登录失败
 *  RETURN_SUCCESS: 登录数据库成功
 */
int DBConnect(HDBC hdbc, char *username, char *password, char *database)
{
	DBUG_ENTER(__func__);

	if(hdbc == NULL || username == NULL || password == NULL)
		DBUG_RETURN(RETURN_INVALID);

	sprintf(hdbc->username, "%s", username);
	sprintf(hdbc->password, "%s", password);
	sprintf(hdbc->database, "%s", database?database:"");

	if(Proc_db_connect(hdbc) != RETURN_SUCCESS)
	{
		DBUG_PRINT(__func__, ("%s", hdbc->error->errstr));
		DBUG_RETURN(RETURN_FAILURE);
	}

	DBUG_RETURN(RETURN_SUCCESS);
}

/**
 * DBDisconnect - 断开数据库连接
 *
 * @hdbc: 连接句柄
 *
 * return value:
 *  RETURN_INVALID: 参数无效
 *  RETURN_FAILURE: 断开连接失败
 *  RETURN_SUCCESS: 断开连接成功
 */
int DBDisconnect(HDBC hdbc)
{
	DBUG_ENTER(__func__);

	if(hdbc == NULL)
		DBUG_RETURN(RETURN_INVALID);

	EXEC SQL COMMIT WORK RELEASE;
	if( SQLCODE != IAPSUCC )
	{
		dbSetORAError(hdbc->error);

		DBUG_PRINT(__func__, ("LINE:%d DBCLOSEDATABASE END UNSUCCESSFULLY!!!The uncommitted transaction hasn't committed!!!",__LINE__));
		DBUG_PRINT(__func__, ("%s", hdbc->error->errstr));

		DBUG_RETURN(RETURN_FAILURE);
	}

	DBUG_PRINT(__func__, ("LINE:%d DBCLOSEDATABASE SUCCESSFULLY END!!!",__LINE__));

	DBUG_RETURN(RETURN_SUCCESS);
}

/**
 * DBStmtInitialize - 数据库操纵句柄初始化
 *
 * @hdbc: 数据库连接句柄
 * @hstmt: 数据库操纵句柄
 *
 * return value:
 *  RETURN_INVALID: 参数无效
 *  RETURN_FAILURE: 内存申请失败
 *  RETURN_SUCCESS: 句柄初始化成功
 */
int DBStmtInitialize(HDBC hdbc, HSTMT *hstmt)
{
	DBUG_ENTER(__func__);

	if(hdbc == NULL || hstmt == NULL)
		DBUG_RETURN(RETURN_INVALID);

	*hstmt = malloc(sizeof(statement));
	if(*hstmt == NULL)
	{
		DBUG_RETURN(RETURN_FAILURE);
	}

	error_info *err = malloc(sizeof(error_info));
	if(err == NULL)
	{
		mFree(*hstmt);
		DBUG_RETURN(RETURN_FAILURE);
	}

	(*hstmt)->table = NULL;
	(*hstmt)->hdbc = hdbc;
	(*hstmt)->error = err;
	(*hstmt)->statement = NULL;
	(*hstmt)->max_row_count = ORA_MAX_ROW_COUNT;
	(*hstmt)->row_count = 0;
	(*hstmt)->table_size = 0;
	(*hstmt)->map_size = 0;
	(*hstmt)->result_code = ORA_SQL_EXEC_RESULT_CODE_FAILURE;

	DBUG_RETURN(RETURN_SUCCESS);
}

/**
 * DBStmtFinished - 数据库操纵句柄使用结束，释放资源
 *
 * @hstmt: 操纵句柄
 *
 * return value:
 *  RETURN_INVALID: 参数无效
 *  RETURN_SUCCESS: 释放成功
 */
int DBStmtFinished(HSTMT hstmt)
{
	DBUG_ENTER(__func__);

	if(hstmt == NULL)
		DBUG_RETURN(RETURN_INVALID);

	hstmt->hdbc = NULL;
	mFree(hstmt->error);
	mFree(hstmt->table);
	mFree(hstmt);

	DBUG_RETURN(RETURN_SUCCESS);
}

static int releaseDescriptors(int max_item);
static int fetchQueryStatmentResult(HSTMT hstmt);

/**
 * DBExecute - 执行SQL语句
 *
 * @hstmt: 数据库操纵句柄
 * @statement: SQL语句
 *
 * return value:
 *  RETURN_INVALID: 参数无效
 *  RETURN_FAILURE: SQL执行失败
 *  RETURN_SUCCESS: SQL执行成功
 */
int DBExecute(HSTMT hstmt, char *statement)
{
	DBUG_ENTER(__func__);

	EXEC SQL BEGIN DECLARE SECTION;
	char caSqlStmt[ORA_MAX_SQL_LEN];
	EXEC SQL VAR caSqlStmt IS STRING(ORA_MAX_SQL_LEN);
	EXEC SQL END DECLARE SECTION;

	if(hstmt == NULL || statement == NULL)
		DBUG_RETURN(RETURN_INVALID);

	sprintf(caSqlStmt, "%s", statement);

	//******************************************************************
	//
	// If is Non query sql statement, execute immediate and return
	//
	//******************************************************************
	if( ! isSelectStatment(caSqlStmt))
	{
		hstmt->statement_type = SQL_TYPE_NONE_QUERY;
		if(IAPSUCC != runNonQueryStatment(hstmt, statement))
		{
			DBUG_RETURN(RETURN_FAILURE);
		}
		DBUG_RETURN(RETURN_SUCCESS);
	}

	//******************************************************************
	//
	// Query sql statement shuld be prepare and descript before execute
	//
	//******************************************************************

	hstmt->statement_type = SQL_TYPE_QUERY;

	if(allocDescriptors(hstmt, ORA_SQL_MAX_ITEM_NUM, ORA_COLUMN_NAME_LEN, ORA_INDICATE_NAME_LEN) != 0)
	{
		DBUG_PRINT("allocDescriptors", ("%s", hstmt->error->errstr));
		DBUG_RETURN(RETURN_FAILURE);
	}

	EXEC SQL PREPARE S FROM :caSqlStmt;
	EXEC SQL DECLARE C CURSOR FOR S;
	EXEC SQL OPEN C USING DESCRIPTOR bind_dp;

	if(SQLCODE != IAPSUCC)
	{
		dbSetORAError(hstmt->error);
		releaseDescriptors(ORA_SQL_MAX_ITEM_NUM);
		DBUG_RETURN(RETURN_FAILURE);
	}

	if(IAPSUCC != fetchQueryStatmentResult(hstmt))
	{
		DBUG_PRINT("fetchQueryStatmentResult", ("%s", hstmt->error->errstr));
	}

	releaseDescriptors(ORA_SQL_MAX_ITEM_NUM);

	DBUG_RETURN(RETURN_SUCCESS);
}

/**
 * releaseDescriptors - 释放指示变量和存储数据变量空间
 *
 * @max_item: 变量最大个数
 *
 * return value:
 *  IAPSUCC: 只返回成功，不应该出错
 */
/*STATIC*/ int releaseDescriptors(int max_item)
{
	DBUG_ENTER(__func__);
	int i;
	for (i = 0; i < max_item; i++)
	{
		if(bind_dp->V[i] != NULL)
			mFree(bind_dp->V[i]);
		mFree(bind_dp->I[i]);
		if(select_dp->V[i] != NULL)
			mFree(select_dp->V[i]);
		mFree(select_dp->I[i]);
	}

	SQLSQLDAFree(SQL_SINGLE_RCTX, bind_dp);
	SQLSQLDAFree(SQL_SINGLE_RCTX, select_dp);
	EXEC SQL CLOSE C;

	bind_dp = NULL;
	select_dp = NULL;
	DBUG_RETURN(IAPSUCC);
}

/**
 * allocEnoughSpaceForField - 为存储字段信息申请足够的空间
 *
 * @hstmt: 操纵句柄
 *
 * return value:
 *  IAPSUCC: 执行成功
 */
static int allocEnoughSpaceForField(HSTMT hstmt)
{
	DBUG_ENTER(__func__);

	int i, null, precision, scale;
	field_attr *field = hstmt->table->field;

	for (i = 0; i < select_dp->F; i++)
	{
		SQLColumnNullCheck (SQL_SINGLE_RCTX,
				(unsigned short*)&(select_dp->T[i]), (unsigned short*)&(select_dp->T[i]), &null);
		field[i].type = select_dp->T[i];

		switch (select_dp->T[i])
		{
			case ORA_SQL_FIELD_TYPE_VCHAR2 :
			case ORA_SQL_FIELD_TYPE_CHAR :
				break;

			case ORA_SQL_FIELD_TYPE_NUMBER :
				SQLNumberPrecV6 (SQL_SINGLE_RCTX,
						(unsigned int*)&(select_dp->L[i]), &precision, &scale);

				if(precision>0 || scale>0)
					select_dp->L[i] = precision+scale+(scale>0?1:0);
				else
					select_dp->L[i] = 24;
				select_dp->T[i] = 1;
				break;

			case ORA_SQL_FIELD_TYPE_LONG :
				select_dp->L[i] = 240;
				break;

			case ORA_SQL_FIELD_TYPE_ROWID :
				select_dp->L[i] = 18;
				break;

			case ORA_SQL_FIELD_TYPE_DATE :
				select_dp->L[i] = 9;
				select_dp->T[i] = 1;
				break;

			case ORA_SQL_FIELD_TYPE_RAW :
				break;

			case ORA_SQL_FIELD_TYPE_LRAW :
				select_dp->L[i] = 240;
				break;
		}

		if (select_dp->T[i] != ORA_SQL_FIELD_TYPE_LRAW &&
				select_dp->T[i] != ORA_SQL_FIELD_TYPE_NUMBER)
			select_dp->T[i] = ORA_SQL_FIELD_TYPE_VCHAR2;

		if (select_dp->T[i] == ORA_SQL_FIELD_TYPE_NUMBER)
			select_dp->T[i] = scale ? ORA_SQL_FIELD_TYPE_FLOAT : ORA_SQL_FIELD_TYPE_INTEGER;

		field[i].capacity = select_dp->L[i];
		snprintf((char*)field[i].name, strlen((char*)field[i].name), "%.*s", select_dp->C[i], select_dp->S[i]);

		hstmt->table_size += select_dp->L[i];
		select_dp->V[i] = realloc(select_dp->V[i], select_dp->L[i] + 1);
	}

	DBUG_RETURN(IAPSUCC);
}

/**
 * newTableInfo - 创建表属性(字段信息)空间
 *
 * @fields: 表的列数
 *
 * return value:
 *  NULL: 内存不足，申请空间失败
 *  !(NULL): 创建成功
 */
static table_info *newTableInfo(int fields)
{
	table_info *table = malloc(sizeof(table_info));
	if(table == NULL)
		return(NULL);

	table->field = malloc(sizeof(field_attr)*fields);
	if(table->field == NULL)
	{
		mFree(table);
		return(NULL);
	}

	table->table_name[0] = 0;
	table->fields = fields;

	return(table);
}

/**
 * allocFixedSpaceForResultSet - 申请大块内存用于存储SELECT返回结果
 *
 * @hstmt: 数据库操作句柄
 *
 * return value:
 *  RETURN_INVALID: 参数无效
 *  RETURN_FAILURE: 申请空间失败
 *  RETURN_SUCCESS: 申请成功
 */
static int allocFixedSpaceForResultSet(HSTMT hstmt)
{
	if(hstmt == NULL)
		return(RETURN_INVALID);

	hstmt->map_size = hstmt->table_size * hstmt->max_row_count;
	hstmt->result = malloc(hstmt->map_size);
	if(hstmt->result == NULL)
	{
		dbSetError(hstmt->error, "Allocate memory(size=%d) fail. %s", hstmt->map_size, strerror(ENOMEM));
		return(RETURN_FAILURE);
	}

	return(RETURN_SUCCESS);
}

/**
 * fetchQueryStatmentResult - 获取查询语句结果
 *
 * @hstmt: 操作句柄
 *
 * 执行返回成功时，还应该检查@hstmt的成员@result_code的值，
 * 当其值为ORA_SQL_EXEC_RESULT_CODE_NOT_FOUND时表示找不到记录
 *
 * return value:
 *  IAPFAIL: 参数无效或获取数据失败
 *  IAPSUCC: 获取数据成功
 */
/*STATIC*/ int fetchQueryStatmentResult(HSTMT hstmt)
{
	DBUG_ENTER(__func__);

	int i;
	int offset = 0;
	char value[4000];

	if(hstmt == NULL)
		DBUG_RETURN(IAPFAIL);

	select_dp->N = ORA_SQL_MAX_ITEM_NUM;

	EXEC SQL DESCRIBE SELECT LIST FOR S INTO select_dp;
	if (select_dp->F < 0)
	{
		dbSetError(hstmt->error, "Too many select-list items(%d), maximum is %d\n",
				-(select_dp->F), ORA_SQL_MAX_ITEM_NUM);
		DBUG_RETURN(IAPFAIL);
	}

	select_dp->N = select_dp->F;

	hstmt->table = newTableInfo(select_dp->N);
	if(hstmt->table == NULL)
	{
		dbSetErrorWithErrno(hstmt->error, ENOMEM);
		DBUG_RETURN(IAPFAIL);
	}

	//******************************************************************
	//
	// @allocEnoughSpaceForField must be called before
	// @allocFixedSpaceForResultSet, because it'll size how much memory
	// for one row.
	//
	//******************************************************************
	if(IAPSUCC != allocEnoughSpaceForField(hstmt))
	{
		DBUG_RETURN(IAPFAIL);
	}

	if(RETURN_SUCCESS != allocFixedSpaceForResultSet(hstmt))
	{
		DBUG_RETURN(IAPFAIL);
	}

	for (;sqlca.sqlerrd[2]<ORA_MAX_ROW_COUNT;)
	{
		EXEC SQL FETCH C USING DESCRIPTOR select_dp;
		if(SQLCODE==1403)
		{
			break;
		}
		else if(SQLCODE<0)
		{
			dbSetORAError(hstmt->error);
			DBUG_RETURN(IAPFAIL);
		}

		for (i = 0; i < select_dp->F; i++)
		{
			memset(value, 0x0, sizeof(value));

			if (*select_dp->I[i] >= 0)
			{
				memcpy(value, select_dp->V[i], select_dp->L[i]);
				rtrim(value, select_dp->L[i]);

				if(hstmt->table->field[i].type != ORA_SQL_FIELD_TYPE_VCHAR2 &&
						select_dp->T[i]==ORA_SQL_FIELD_TYPE_VCHAR2)
				{
					ltrim(value, select_dp->L[i]);
				}
				memcpy(hstmt->result+offset, value, strlen(value));
				memset(hstmt->result+offset+strlen(value), 0x0, select_dp->L[i] - strlen(value));
			}
			else
			{
				memset(hstmt->result+offset, 0x0, select_dp->L[i]);
			}
			offset += select_dp->L[i];
		}
	}
	hstmt->row_count = sqlca.sqlerrd[2];

	if(hstmt->row_count == 0)
	{
		hstmt->result_code = ORA_SQL_EXEC_RESULT_CODE_NOT_FOUND;
	}
	else
	{
		hstmt->result_code = ORA_SQL_EXEC_RESULT_CODE_SUCCESS;
	}

	DBUG_RETURN(IAPSUCC);
}
